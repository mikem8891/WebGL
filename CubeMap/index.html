<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="HandheldFriendly" content="true" />
    <meta charset="UTF-8">
    <title>Convert a UV Map to a Cube Map for a Sphere</title>
    <style>

      html, body {
        height: 100%;
      }

      body {
        display: flex;
        flex-direction: column;
        font-family: Arial, Helvetica, sans-serif;
        margin-top: 0px;
      }

      input[type="number"]{
        width : 9ch;
      }

      .flex {
        flex: auto;
      }

      canvas {
        background-color: #000;
      }
    </style>
  </head>
<body>
  <div>
    <h1>Convert a UV Map to a Cube Map for a Sphere</h1>
    <label>output side dimension: 
      <input type="number" id="outputDim"  name="outputDim"  value="512" min="1" onchange="convertUVMapToCubeMap()"/>
    </label>
    <label>Choose a UV map to upload 
      <input type="file" id="myFile" name="myFile" accept="image/*" />
    </label>
    <span id="maxDims"></span>
    <a id="downloadLink" download hidden>Download Cube Map</a>
  </div>
  <div class="flex">
    <table>
      <tr>
        <td></td>
        <td><a id="yPlusLink"  download><img id="yPlus"> </a></td>
        <td></td><td></td>
      </tr>
      <tr>
        <td><a id="xPlusLink"  download><img id="xPlus"> </a></td>
        <td><a id="zPlusLink"  download><img id="zPlus"> </a></td>
        <td><a id="xMinusLink" download><img id="xMinus"></a></td>
        <td><a id="zMinusLink" download><img id="zMinus"></a></td>
      </tr>
      <tr>
        <td></td>
        <td><a id="yMinusLink"  download><img id="yMinus"> </a></td>
        <td></td><td></td>
      </tr>
    </table>
    <img id="sourceImage" hidden>
    <canvas id="renderCanvas" hidden>
      Browser does not support HTML5
    </canvas>
  </div>
  <div>converts an uploaded bump map to a normal map</div>
</body>

<!-- Library for graphics related maxtrix math -->
<script src="../lib/gl-matrix-min.js"></script>

<!-- Vertex Shader Source Code -->
<script id="vshader" type="x-shader/x-vertex">

  precision highp float;

  uniform mat3 uvToNorm;

  attribute vec2 vertPosition;

  varying vec3 fragPosition;

  void main(){
    gl_Position = vec4(vertPosition, 0.0, 1.0);
    fragPosition = uvToNorm * vec3(vertPosition, 1.0);
  }

</script>

<!-- Fragment Shader Source Code -->
<script id="fshader" type="x-shader/x-fragment">

  precision highp float;

  uniform sampler2D samplerText;

  varying vec3 fragPosition;

  void main(){
    const float PI = 3.1415926535;
    float r     = sqrt(dot(fragPosition.xy, fragPosition.xy));
    float theta = atan(fragPosition.y, fragPosition.x);
    float phi   = atan(r, fragPosition.z);
    vec2 fragTexCoord = vec2(theta/(2.0*PI), phi/PI);
    vec4 texel = texture2D(samplerText, fragTexCoord);
    gl_FragColor = texel;
  }

</script>

<!-- Initialize WebGL canvas -->
<script>

const canvas = document.getElementById('renderCanvas');
var gl;
var program;

function main(){
  // Get context
  gl = canvas.getContext('webgl2');
  if(!gl){
    console.log('Attempting to use "webgl" context.');
    gl = canvas.getContext('webgl');
  }
  if(!gl){
    console.log('Attempting to use "experimental-webgl" context.');
    gl = canvas.getContext('experimental-webgl');
  }
  if(!gl){
    alert('WebGL is not supported');
    return;
  }

  document.getElementById('maxDims').innerHTML = 'The max image dimension allowed is ' + gl.getParameter(gl.MAX_TEXTURE_SIZE) + 'px';
}

var image;

document.getElementById('myFile').oninput =  function(evt){
  var file = evt.target.files[0];
  if (!file){
    console.error('ERROR: no file loaded');
    return;
  }
  var reader = new FileReader();
  var img = document.getElementById('sourceImage');
  img.onload = function(){
    image = img;
    convertUVMapToCubeMap();
  }
  reader.onload = function(){
    img.src = reader.result;
  }
  reader.readAsDataURL(file);
}

function convertUVMapToCubeMap(){
  // Set size of the canvas based on inputs

  var dim  = Number(document.getElementById('outputDim').value);
  if (dim <= 0){
    console.error('ERROR: fix output dimension');
    return;
  }
  canvas.width  = dim;
  canvas.height = dim;
  canvas.style.width  = dim + 'px';
  canvas.style.height = dim + 'px';

  gl.viewport(0, 0, canvas.width, canvas.height)

  if (!image)
    return;

  if (!program){
    // Create Blank Shaders Object
    var vertexShader   = gl.createShader(gl.VERTEX_SHADER);
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);

    // Get shader source code
    var vertexShaderText   = document.getElementById('vshader').innerHTML;
    var fragmentShaderText = document.getElementById('fshader').innerHTML;

    // Set shader source code
    gl.shaderSource(vertexShader,   vertexShaderText);
    gl.shaderSource(fragmentShader, fragmentShaderText);
    
    // Compiler shader with source code
    gl.compileShader(vertexShader);
    gl.compileShader(fragmentShader);

    // Check for compilation errors
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)){
      alert('ERROR compiling vertex shader!', 
                    gl.getShaderInfoLog(vertexShader));
      return;
    }
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)){
      alert('ERROR compiling fragment shader!\n' + gl.getShaderInfoLog(fragmentShader));
      return;
    }
    
    // Create and link the program to run the shaders
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    
    // Check for errors
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)){
      alert('ERROR linking program\n' + 
                    gl.getProgramInfoLog(program));
      return;
    }
    gl.validateProgram(program);
    if (!gl.getProgramParameter(program, gl.VALIDATE_STATUS)){
      alert('ERROR validating program', 
                    gl.getProgramInfoLog(program));
      return;
    }

    var verts = [
      // X,    Y,
      -1.0,  1.0, 
      -1.0, -1.0,
       1.0,  1.0,
      
      -1.0, -1.0,
       1.0,  1.0,
       1.0, -1.0
    ]

    var vertBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verts), gl.STATIC_DRAW);
    var positionAttribLocation = gl.getAttribLocation(program, 'vertPosition'); 
    gl.vertexAttribPointer(
      positionAttribLocation,  // Attribute location 
      2,                       // Number of elements per attribute (X, Y)
      gl.FLOAT,                // Data type of the elements
      gl.FALSE,                // Whether the elements are normalized
      2 * Float32Array.BYTES_PER_ELEMENT,  // Size of an individual vertex
      0  // Offset from the beginning of a single vertex to this attribute
    );
    gl.enableVertexAttribArray(positionAttribLocation);   // Enables the attribute
  }

  var uvToNorm = [
    // X+
    [ 0,  0,  1,
      0,  1,  0,
      1,  0,  0],
    // X-
    [ 0,  0, -1,
      0,  1,  0,
      -1,  0,  0],
    // Y+
    [-1,  0,  0,
      0,  0, -1,
      0,  1,  0],
    // Y-
    [-1,  0,  0,
      0,  0,  1,
      0, -1,  0],
    // Z+
    [-1,  0,  0,
      0,  1,  0,
      0,  0,  1],
    // Z-
    [ 1,  0,  0,
      0,  1,  0,
      0,  0, -1]
  ];

  var cubeFaceNames = [
    'xPlus', 'xMinus',
    'yPlus', 'yMinus',
    'zPlus', 'zMinus',
  ];

  // Set uniforms (shader constants)
  // Textures
  var uvMap = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, uvMap);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR)
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR)
  gl.texImage2D(
    gl.TEXTURE_2D, // target (a 2D texture)
    0,             // level (level 0 is the base image)
    gl.RGBA,       // internal format 
    gl.RGBA,       // format (in WebGL this needs to match the internal format)
    gl.UNSIGNED_BYTE, // type (8 bits per channel for gl.RGBA)
    image  // pixels (HTMLImageElement)
  );

  // Tells WebGL what program to use
  gl.useProgram(program);
  
  var uvMapLoc = gl.getUniformLocation(program, "samplerText");
  gl.uniform1i(uvMapLoc, 0);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, uvMap);

  // Output dimensions (uniforms)
  for(let i=0; i<6; i++){
    var uvToNormMatLocation = gl.getUniformLocation(program, 'uvToNorm');
    gl.uniformMatrix3fv(uvToNormMatLocation, gl.FALSE, new Float32Array(uvToNorm[i]));
    
    // Clears the canvas
    gl.clearColor(0.0, 0.5, 0.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
  
    gl.drawArrays(gl.TRIANGLES, 0, 6);
    
    // Set download link
    var faceImage     = document.getElementById(cubeFaceNames[i]);
    var downloadLink  = document.getElementById(cubeFaceNames[i] + 'Link');
    var imageData     = canvas.toDataURL();
    faceImage.src     = imageData;
    downloadLink.href = imageData;
    downloadLink.download = cubeFaceNames[i] + '.png';
  }
}
window.onload = main;
</script>
</html>