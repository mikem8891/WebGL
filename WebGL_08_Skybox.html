<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="HandheldFriendly" content="true" />
    <meta charset="UTF-8">
    <title>WebGL Demo 8: Sky Box</title>
    <style>

      html, body {
        height: 100%;
      }

      body {
        background-color: #111;
        color: #DDD;
        display: flex;
        flex-direction: column;
        font-family: Arial, Helvetica, sans-serif;
        margin-top: 0px;
      }

      .flex {
        flex: auto;
        overflow: hidden;
      }

      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
<body>
  <div><h1>WebGL Demo 8: Sky Box</h1></div>
  <div class="flex">
    <canvas id="renderCanvas">
      Browser does not support HTML5
    </canvas>
  </div>
  <div>Demo of the Earth with a stary skybox.</div>
</body>

<!-- Library for graphics related maxtrix math -->
<script src="lib/gl-matrix-min.js"></script>

<!-- Custom utility library for this demo -->
<script src="Demo_8/util.js"></script>

<!-- Initialize WebGl canvas -->
<script>

function main(){
  // load files and runs the demo
  loadAssets();
}

function loadAssets(){
  console.log('Working');
  
  const canvas = document.getElementById('renderCanvas');
  var context = 'webgl2';
  var gl = canvas.getContext(context);

  if(!gl){
    context = 'webgl';
    console.log('Attempting to use "' + context + '" context.');
    gl = canvas.getContext(context);
  }
  
  if(!gl){
    context = 'experimental-webgl';
    console.log('Attempting to use "' + context + '" context.');
    gl = canvas.getContext(context);
  }

  var internalFormat;
  if(!gl){
    console.error('WebGL not supported');
    alert('WebGL not supported');
    return;
  } else if (context == 'webgl2'){
    internalFormat = gl.SRGB8_ALPHA8;
  } else {
    internalFormat = gl.RGBA;
  }
  
  // asynchonously link the shaders to the program
  var programPromise = createLinkedProgram(gl, 'Demo_8/vshader.glsl', 'Demo_8/fshader.glsl');
  
  // Clears the canvas
  gl.clearColor(0.05, 0.05, 0.05, 1.00);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.clear(gl.DEPTH_BUFFER_BIT);
  
  // Prevent the back side (gl.BACK) of triangles from being drawn
  // The front face is defined as counter-clockwise points (gl.CCW)
  gl.enable(gl.CULL_FACE);
  gl.frontFace(gl.CCW); // this is defualt front face
  gl.cullFace(gl.BACK); // this is defualt culled face
  //gl.cullFace(gl.FRONT);
  
  // Only the closest geometry is visible (uses the depth buffer) 
  gl.enable(gl.DEPTH_TEST);
  
  // asynchonously load the model into the program
  var earthModelPromise = loadEarthModel(gl, programPromise, 'sphere.json');
  var skyScreen = loadSkyScreen(gl);

  // Create blank textures
  var earthCubeMap = gl.createTexture();
  var earthSpec    = gl.createTexture();
  var earthNorm    = gl.createTexture();
  var starMap      = gl.createTexture();

  // bind textures
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_CUBE_MAP, earthCubeMap);
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_CUBE_MAP, earthSpec);
  gl.activeTexture(gl.TEXTURE2);
  gl.bindTexture(gl.TEXTURE_CUBE_MAP, earthNorm);
  gl.activeTexture(gl.TEXTURE3);
  gl.bindTexture(gl.TEXTURE_CUBE_MAP, starMap);


  loadCubemap('Earth/True_Color/Cube/').then(function(texture){
    console.log('Earth texture loaded @:', performance.now());
    gl.activeTexture(gl.TEXTURE0);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, internalFormat, gl.RGBA, gl.UNSIGNED_BYTE, texture[0]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, internalFormat, gl.RGBA, gl.UNSIGNED_BYTE, texture[1]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, internalFormat, gl.RGBA, gl.UNSIGNED_BYTE, texture[2]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, internalFormat, gl.RGBA, gl.UNSIGNED_BYTE, texture[3]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, internalFormat, gl.RGBA, gl.UNSIGNED_BYTE, texture[4]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, internalFormat, gl.RGBA, gl.UNSIGNED_BYTE, texture[5]);
    gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
  }).catch(function (err) {console.error(err);});
  
  loadCubemap('Earth/Specular/Cube/').then(function(specMap){
    console.log('Earth specular map loaded @:', performance.now());
    gl.activeTexture(gl.TEXTURE1);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.LUMINANCE, gl.LUMINANCE, gl.UNSIGNED_BYTE, specMap[0]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.LUMINANCE, gl.LUMINANCE, gl.UNSIGNED_BYTE, specMap[1]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.LUMINANCE, gl.LUMINANCE, gl.UNSIGNED_BYTE, specMap[2]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.LUMINANCE, gl.LUMINANCE, gl.UNSIGNED_BYTE, specMap[3]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.LUMINANCE, gl.LUMINANCE, gl.UNSIGNED_BYTE, specMap[4]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.LUMINANCE, gl.LUMINANCE, gl.UNSIGNED_BYTE, specMap[5]);
    gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
  }).catch(function (err) {console.error(err);});

  loadCubemap('Earth/Normals/Cube/').then(function(normMap){
    console.log('Earth normal map loaded @:', performance.now());
    gl.activeTexture(gl.TEXTURE2);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, normMap[0]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, normMap[1]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, normMap[2]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, normMap[3]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, normMap[4]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, normMap[5]);
    gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
  }).catch(function (err) {console.error(err);});

  loadCubemap('Stars/all/Cube/').then(function(skyMap){
    console.log('Star map loaded @:', performance.now());
    gl.activeTexture(gl.TEXTURE3);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
    gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, skyMap[0]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, skyMap[1]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, skyMap[2]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, skyMap[3]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, skyMap[4]);
    gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, skyMap[5]);
    gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
  }).catch(function (err) {console.error(err);});

  runDemo(gl, programPromise, earthModelPromise);
}

async function loadEarthModel(gl, programPromise, url){

  var earth = {};

  // Load json from url
  model = await loadJSON(url);
  console.log('JSON model loaded @:', performance.now());

  // Typically this is 'model.meshes[i].vertices' in a JSON model;
  earth.vertices = model.meshes[0].vertices;
  
  // Specify normals
  // Typically this is 'model.meshes[i].normals' in a JSON model;
  earth.normals    = model.meshes[0].normals;
  earth.tangents   = model.meshes[0].tangents;
  earth.bitangents = model.meshes[0].bitangents;
  
  // Specify the texture coordinates
  // Typically this is 'model.meshes[i].texturecoords[j]' in a JSON model;
  earth.texCoords = model.meshes[0].texturecoords[0];
  
  // Specify the indices for each face
  // Typically this is '[].concat.apply([], model.meshes[i].faces)' in a JSON model;
  earth.indices = [].concat.apply([], model.meshes[0].faces);
  
  // Create buffers
  // Set Attributes (shader inputs)
  var earthVertexBufferObject = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, earthVertexBufferObject);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(earth.vertices), gl.STATIC_DRAW);
  
  var earthTexCoordBufferObject = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, earthTexCoordBufferObject);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(earth.texCoords), gl.STATIC_DRAW);
  
  var earthNormBufferObject = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, earthNormBufferObject);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(earth.normals), gl.STATIC_DRAW);
  var earthTanBufferObject = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, earthTanBufferObject);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(earth.tangents), gl.STATIC_DRAW);
  var earthBitanBufferObject = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, earthBitanBufferObject);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(earth.bitangents), gl.STATIC_DRAW);
  
  var earthIndexBufferObject = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, earthIndexBufferObject);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(earth.indices), gl.STATIC_DRAW);
  
  program = await programPromise;
  
  gl.bindBuffer(gl.ARRAY_BUFFER, earthVertexBufferObject);
  var positionAttribLocation = gl.getAttribLocation(program, 'vertPosition'); 
  gl.vertexAttribPointer(
    positionAttribLocation,  // Attribute location 
    3,                       // Number of elements per attribute (X, Y, Z)
    gl.FLOAT,                // Data type of the elements
    gl.FALSE,                // Whether the elements are normalized
    3 * Float32Array.BYTES_PER_ELEMENT,  // Size of an individual vertex
    0  // Offset from the beginning of a single vertex to this attribute
  );
  gl.enableVertexAttribArray(positionAttribLocation); // Enables the attribute
  
  gl.bindBuffer(gl.ARRAY_BUFFER, earthNormBufferObject);
  var normalAttribLocation = gl.getAttribLocation(program, 'vertNormal'); 
  gl.vertexAttribPointer(
    normalAttribLocation,  // Attribute location 
    3,                     // Number of elements per attribute (X, Y, Z)
    gl.FLOAT,              // Data type of the elements
    gl.TRUE,               // Whether the elements are normalized
    3 * Float32Array.BYTES_PER_ELEMENT,  // Size of an individual vertex
    0  // Offset from the beginning of a single vertex to this attribute
  );
  gl.enableVertexAttribArray(normalAttribLocation); // Enables the attribute

  gl.bindBuffer(gl.ARRAY_BUFFER, earthTanBufferObject);
  var tangentAttribLocation = gl.getAttribLocation(program, 'vertTangent'); 
  gl.vertexAttribPointer(
    tangentAttribLocation,  // Attribute location 
    3,                     // Number of elements per attribute (X, Y, Z)
    gl.FLOAT,              // Data type of the elements
    gl.TRUE,               // Whether the elements are normalized
    3 * Float32Array.BYTES_PER_ELEMENT,  // Size of an individual vertex
    0  // Offset from the beginning of a single vertex to this attribute
  );
  gl.enableVertexAttribArray(tangentAttribLocation); // Enables the attribute

  gl.bindBuffer(gl.ARRAY_BUFFER, earthNormBufferObject);
  var bitanAttribLocation = gl.getAttribLocation(program, 'vertBitan'); 
  gl.vertexAttribPointer(
    bitanAttribLocation,  // Attribute location 
    3,                     // Number of elements per attribute (X, Y, Z)
    gl.FLOAT,              // Data type of the elements
    gl.TRUE,               // Whether the elements are normalized
    3 * Float32Array.BYTES_PER_ELEMENT,  // Size of an individual vertex
    0  // Offset from the beginning of a single vertex to this attribute
  );
  gl.enableVertexAttribArray(bitanAttribLocation); // Enables the attribute

  gl.bindBuffer(gl.ARRAY_BUFFER, earthTexCoordBufferObject);
  var texCoordAttribLocation = gl.getAttribLocation(program, 'vertTexCoord'); 
  gl.vertexAttribPointer(
    texCoordAttribLocation,  // Attribute location 
    2,                       // Number of elements per attribute (S, T)
    gl.FLOAT,                // Data type of the elements
    gl.FALSE,                // Whether the elements are normalized
    2 * Float32Array.BYTES_PER_ELEMENT,  // Size of an individual vertex
    0 // Offset from the beginning of a single vertex to this attribute
  );
  gl.enableVertexAttribArray(texCoordAttribLocation); // Enables the attribute
  
  return earth;
}

async function loadSkyScreen(gl, skyboxProgramPromise){
  var screen = [
  // X,  Y,
    -1,  1,
    -1, -1,
     1,  1,

     1,  1,
    -1, -1,
     1, -1
  ];

  

}

async function runDemo(gl, programPromise, earthModelPromise){

  var canvas  = gl.canvas;

  program = await programPromise;

  // Tells WebGL what program to use
  gl.useProgram(program);

  var earthTextLoc = gl.getUniformLocation(program, "samplerText");
  var earthSpecLoc = gl.getUniformLocation(program, "samplerSpec");
  var earthNormLoc = gl.getUniformLocation(program, "samplerNorm");
  gl.uniform1i(earthTextLoc, 0);
  gl.uniform1i(earthSpecLoc, 1);
  gl.uniform1i(earthNormLoc, 2);
  
  // Matrices
  var viewPositionLocation    = gl.getUniformLocation(program, 'viewPos');
  var matWorldUniformLocation = gl.getUniformLocation(program, 'mWorld'); 
  var matViewUniformLocation  = gl.getUniformLocation(program, 'mView'); 
  var matProjUniformLocation  = gl.getUniformLocation(program, 'mProj');
  
  var viewPosition = [0, -5, 0];
  var matWorld = new Float32Array(16);
  var matView  = new Float32Array(16);
  var matProj  = new Float32Array(16);
  glMatrix.mat4.identity(matWorld);
  glMatrix.mat4.lookAt(matView, viewPosition, [0, 0, 0], [0, 0, 1]);
  glMatrix.mat4.perspective(matProj, glMatrix.glMatrix.toRadian(30), canvas.width / canvas.height, 0.1, 1000);
  
  gl.uniform3fv(viewPositionLocation, new Float32Array(viewPosition));
  gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, matWorld);
  gl.uniformMatrix4fv(matViewUniformLocation,  gl.FALSE, matView);
  gl.uniformMatrix4fv(matProjUniformLocation,  gl.FALSE, matProj);
  
  // Lighting information
  gl.useProgram(program);
  var ambLightIntUniformLocation = gl.getUniformLocation(program, 'ambLightInt'); 
  var sunlightIntUniformLocation = gl.getUniformLocation(program, 'sun.color'); 
  var sunlightDirUniformLocation = gl.getUniformLocation(program, 'sun.direction'); 
  
  gl.uniform3f(ambLightIntUniformLocation,  0.01,  0.01,  0.01);
  gl.uniform3f(sunlightIntUniformLocation,   1.0,   1.0,   1.0);
  gl.uniform3f(sunlightDirUniformLocation,   4.0,  -3.0,   0.0);
  
  // Main render loop for something like a game in JS (just for info)
  /*
  var loop = function () {
    updateWorld();
    renderWorld();
    if (running)
      requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
  */
  
  // Our main render loop
  
  var identityMatrix = new Float32Array(16);
  var xRotMat        = new Float32Array(16);
  var zRotMat        = new Float32Array(16);
  glMatrix.mat4.identity(identityMatrix);
  var ang = 0;
  var earth;
  function loop(){
    // rotates the earth
    ang = performance.now() / 1000 / 20 * 2 * Math.PI;
    glMatrix.mat4.rotate(zRotMat, identityMatrix, ang,   [0, 0, 1]);
    glMatrix.mat4.rotate(xRotMat, identityMatrix, Math.PI/3*Math.sin(ang/3), [1, 0, 0]);
    glMatrix.mat4.mul(matWorld, xRotMat, zRotMat);
    gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, matWorld)

    // Resize canvas
    var resized = resizeCanvas(gl);
    if (resized) {
      var minFOV = glMatrix.glMatrix.toRadian(30);
      var vertFOV = minFOV;
      if (canvas.height > canvas.width) {
        var distFOV = canvas.width / Math.tan(minFOV);
        vertFOV = Math.atan(canvas.height / distFOV);
      }
      glMatrix.mat4.perspective(matProj, vertFOV, canvas.width / canvas.height, 0.1, 1000);
    }
    gl.uniformMatrix4fv(matProjUniformLocation, gl.FALSE, matProj)

    // Clears the canvas
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    
    gl.depthFunc(gl.LESS);
    gl.drawElements(gl.TRIANGLES, earth.indices.length, gl.UNSIGNED_SHORT, 0);
    
    requestAnimationFrame(loop); // loop is called when a frame is requested
  }
  earth = await earthModelPromise;
  requestAnimationFrame(loop);
}

function resizeCanvas(gl) {
  var canvas = gl.canvas;
  if (!canvas)
    return false;

  var canvasBox = canvas.getBoundingClientRect();
  var DPR = window.devicePixelRatio || 1;

  var displayWidth  = Math.round(canvasBox.width  * DPR);
  var displayHeight = Math.round(canvasBox.height * DPR);

  if (canvas.width != displayWidth || canvas.height != displayHeight) {
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
    gl.viewport(0, 0, displayWidth, displayHeight);
    return true;
  }
  return false;
}

window.onload = main;
</script>
</html>