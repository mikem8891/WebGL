<!DOCTYPE html>
<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <meta name="HandheldFriendly" content="true" />
    <meta charset="UTF-8">
    <title>WebGL Demo 8: Sky Box</title>
    <style>

      html, body {
        height: 100%;
      }

      body {
        background-color: #111;
        color: #DDD;
        display: flex;
        flex-direction: column;
        font-family: Arial, Helvetica, sans-serif;
        margin-top: 0px;
      }

      .flex {
        flex: auto;
        overflow: hidden;
      }

      canvas {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
<body>
  <div><h1>WebGL Demo 8: Sky Box</h1></div>
  <div class="flex">
    <canvas id="renderCanvas">
      Browser does not support HTML5
    </canvas>
  </div>
  <div>Demo of the Earth with a stary skybox.</div>
</body>

<!-- Library for graphics related maxtrix math -->
<script src="lib/gl-matrix-min.js"></script>

<!-- Custom utility library for this demo -->
<script src="Demo_8/util.js"></script>

<!-- Initialize WebGl canvas -->
<script>

function main(){
  // load files and run the demo
  loadAssets();
}

function loadAssets(){  
  Promise.all([
    loadCubemap('Earth/True_Color/Cube/'),
    loadCubemap('Earth/Specular/Cube/'),
    loadImage('Earth/earth_normMap.png')
  ]).then(function ([texture, specMap, normMap]) {
      runDemo(texture, specMap, normMap);})
    .catch(function (err) {console.error(err);});
}



function runDemo(texture, specMap, normMap){
  console.log('Working');
  
  const canvas = document.getElementById('renderCanvas');
  var context = 'webgl2';
  var gl = canvas.getContext(context);

  if(!gl){
    context = 'webgl';
    console.log('Attempting to use "' + context + '" context.');
    gl = canvas.getContext(context);
  }
  
  if(!gl){
    context = 'experimental-webgl';
    console.log('Attempting to use "' + context + '" context.');
    gl = canvas.getContext(context);
  }

  var internalFormat;
  if(!gl){
    console.error('WebGL not supported');
    alert('WebGL not supported');
    return;
  } else if (context == 'webgl2'){
    internalFormat = gl.SRGB8_ALPHA8;
  } else {
    internalFormat = gl.RGBA;
  }
  
  // asynchonously link the shaders to the program
  var linkedProgramPromise = Promise.all([
    loadText('Demo_8/vshader.glsl'),
    loadText('Demo_8/fshader.glsl')
  ]).then(function ([vertexShaderText, fragmentShaderText]){
    if (context == 'webgl2'){
      fragmentShaderText = '#define Convert_sRGB_to_Lin 0 \n' + fragmentShaderText;
    } else {
      fragmentShaderText = '#define Convert_sRGB_to_Lin 1 \n' + fragmentShaderText;
    }
    return shaderProgram(gl, vertexShaderText, fragmentShaderText);
  }).catch(function (err) {console.error(err);});
  
  // Clears the canvas
  gl.clearColor(0.05, 0.05, 0.05, 1.00);
  gl.clear(gl.COLOR_BUFFER_BIT);
  gl.clear(gl.DEPTH_BUFFER_BIT);
  
  // Prevent the back side (gl.BACK) of triangles from being drawn
  // The front face is defined as counter-clockwise points (gl.CCW)
  gl.enable(gl.CULL_FACE);
  gl.frontFace(gl.CCW); // this is defualt front face
  gl.cullFace(gl.BACK); // this is defualt culled face
  //gl.cullFace(gl.FRONT);
  
  // Only the closest geometry is visible (uses the depth buffer) 
  gl.enable(gl.DEPTH_TEST);
  
  // asynchonously load the model into the program
  var earthModelPromise = Promise.all([
    loadJSON('sphere.json'),
    linkedProgramPromise
  ]).then(function ([model, program]){
    // Specify vertices
    // Typically this is 'model.meshes[i].vertices' in a JSON model;
    var earthVertices = model.meshes[0].vertices;
    
    // Specify normals
    // Typically this is 'model.meshes[i].normals' in a JSON model;
    var earthNormals    = model.meshes[0].normals;
    var earthTangents   = model.meshes[0].tangents;
    var earthBitangents = model.meshes[0].bitangents;
    
    // Specify the texture coordinates
    // Typically this is 'model.meshes[i].texturecoords[j]' in a JSON model;
    var earthTexCoords = model.meshes[0].texturecoords[0];
    
    // Specify the indices for each face
    // Typically this is '[].concat.apply([], model.meshes[i].faces)' in a JSON model;
    var earthIndices = [].concat.apply([], model.meshes[0].faces);
    
    // Create buffers
    // Set Attributes (shader inputs)
    var earthVertexBufferObject = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, earthVertexBufferObject);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(earthVertices), gl.STATIC_DRAW);
    
    var earthTexCoordBufferObject = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, earthTexCoordBufferObject);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(earthTexCoords), gl.STATIC_DRAW);
    
    var earthNormBufferObject = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, earthNormBufferObject);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(earthNormals), gl.STATIC_DRAW);
    var earthTanBufferObject = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, earthTanBufferObject);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(earthTangents), gl.STATIC_DRAW);
    var earthBitanBufferObject = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, earthBitanBufferObject);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(earthBitangents), gl.STATIC_DRAW);
    
    var earthIndexBufferObject = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, earthIndexBufferObject);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(earthIndices), gl.STATIC_DRAW);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, earthVertexBufferObject);
    var positionAttribLocation = gl.getAttribLocation(program, 'vertPosition'); 
    gl.vertexAttribPointer(
      positionAttribLocation,  // Attribute location 
      3,                       // Number of elements per attribute (X, Y, Z)
      gl.FLOAT,                // Data type of the elements
      gl.FALSE,                // Whether the elements are normalized
      3 * Float32Array.BYTES_PER_ELEMENT,  // Size of an individual vertex
      0  // Offset from the beginning of a single vertex to this attribute
    );
    gl.enableVertexAttribArray(positionAttribLocation); // Enables the attribute
    
    gl.bindBuffer(gl.ARRAY_BUFFER, earthNormBufferObject);
    var normalAttribLocation = gl.getAttribLocation(program, 'vertNormal'); 
    gl.vertexAttribPointer(
      normalAttribLocation,  // Attribute location 
      3,                     // Number of elements per attribute (X, Y, Z)
      gl.FLOAT,              // Data type of the elements
      gl.TRUE,               // Whether the elements are normalized
      3 * Float32Array.BYTES_PER_ELEMENT,  // Size of an individual vertex
      0  // Offset from the beginning of a single vertex to this attribute
    );
    gl.enableVertexAttribArray(normalAttribLocation); // Enables the attribute

    gl.bindBuffer(gl.ARRAY_BUFFER, earthTanBufferObject);
    var tangentAttribLocation = gl.getAttribLocation(program, 'vertTangent'); 
    gl.vertexAttribPointer(
      tangentAttribLocation,  // Attribute location 
      3,                     // Number of elements per attribute (X, Y, Z)
      gl.FLOAT,              // Data type of the elements
      gl.TRUE,               // Whether the elements are normalized
      3 * Float32Array.BYTES_PER_ELEMENT,  // Size of an individual vertex
      0  // Offset from the beginning of a single vertex to this attribute
    );
    gl.enableVertexAttribArray(tangentAttribLocation); // Enables the attribute

    gl.bindBuffer(gl.ARRAY_BUFFER, earthNormBufferObject);
    var bitanAttribLocation = gl.getAttribLocation(program, 'vertBitan'); 
    gl.vertexAttribPointer(
      bitanAttribLocation,  // Attribute location 
      3,                     // Number of elements per attribute (X, Y, Z)
      gl.FLOAT,              // Data type of the elements
      gl.TRUE,               // Whether the elements are normalized
      3 * Float32Array.BYTES_PER_ELEMENT,  // Size of an individual vertex
      0  // Offset from the beginning of a single vertex to this attribute
    );
    gl.enableVertexAttribArray(bitanAttribLocation); // Enables the attribute

    gl.bindBuffer(gl.ARRAY_BUFFER, earthTexCoordBufferObject);
    var texCoordAttribLocation = gl.getAttribLocation(program, 'vertTexCoord'); 
    gl.vertexAttribPointer(
      texCoordAttribLocation,  // Attribute location 
      2,                       // Number of elements per attribute (S, T)
      gl.FLOAT,                // Data type of the elements
      gl.FALSE,                // Whether the elements are normalized
      2 * Float32Array.BYTES_PER_ELEMENT,  // Size of an individual vertex
      0 // Offset from the beginning of a single vertex to this attribute
    );
    gl.enableVertexAttribArray(texCoordAttribLocation); // Enables the attribute
    
    return earthIndices;

  }).catch(function (err) {console.error(err);});
  

  
  // Create texture
  var earthCubeMap = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_CUBE_MAP, earthCubeMap);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, internalFormat, gl.RGBA, gl.UNSIGNED_BYTE, texture[0]);
  gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, internalFormat, gl.RGBA, gl.UNSIGNED_BYTE, texture[1]);
  gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, internalFormat, gl.RGBA, gl.UNSIGNED_BYTE, texture[2]);
  gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, internalFormat, gl.RGBA, gl.UNSIGNED_BYTE, texture[3]);
  gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, internalFormat, gl.RGBA, gl.UNSIGNED_BYTE, texture[4]);
  gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, internalFormat, gl.RGBA, gl.UNSIGNED_BYTE, texture[5]);
  gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
  
  var earthSpec = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_CUBE_MAP, earthSpec);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
  gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X, 0, gl.LUMINANCE, gl.LUMINANCE, gl.UNSIGNED_BYTE, specMap[0]);
  gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, gl.LUMINANCE, gl.LUMINANCE, gl.UNSIGNED_BYTE, specMap[1]);
  gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, gl.LUMINANCE, gl.LUMINANCE, gl.UNSIGNED_BYTE, specMap[2]);
  gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, gl.LUMINANCE, gl.LUMINANCE, gl.UNSIGNED_BYTE, specMap[3]);
  gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, gl.LUMINANCE, gl.LUMINANCE, gl.UNSIGNED_BYTE, specMap[4]);
  gl.texImage2D(gl.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, gl.LUMINANCE, gl.LUMINANCE, gl.UNSIGNED_BYTE, specMap[5]);
  gl.generateMipmap(gl.TEXTURE_CUBE_MAP);

  var earthNorm = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, earthNorm);
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texImage2D(
    gl.TEXTURE_2D, // target (a 2D texture)
    0,             // level (level 0 is the base image)
    gl.RGBA,       // internal format 
    gl.RGBA,       // format (in WebGL this needs to match the internal format)
    gl.UNSIGNED_BYTE, // type (8 bits)
    normMap  // pixels (HTMLImageElement)
  );
  gl.generateMipmap(gl.TEXTURE_2D);

  Promise.all([
    linkedProgramPromise,
    earthModelPromise
  ]).then(function([program, earthIndices]){
    // Tells WebGL what program to use
    gl.useProgram(program);

    // Set uniforms (shader constants)
    // Textures
    var earthTextLoc = gl.getUniformLocation(program, "samplerText");
    var earthSpecLoc = gl.getUniformLocation(program, "samplerSpec");
    var earthNormLoc = gl.getUniformLocation(program, "samplerNorm");
  //  var skyLoc       = gl.getUniformLocation(program, "samplerSky");
    gl.uniform1i(earthTextLoc, 0);
    gl.uniform1i(earthSpecLoc, 1);
    gl.uniform1i(earthNormLoc, 2);
  //  gl.uniform1i(skyLoc      , 3);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, earthCubeMap);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_CUBE_MAP, earthSpec);
    gl.activeTexture(gl.TEXTURE2);
    gl.bindTexture(gl.TEXTURE_2D, earthNorm);

    // Matrices
    var viewPositionLocation    = gl.getUniformLocation(program, 'viewPos');
    var matWorldUniformLocation = gl.getUniformLocation(program, 'mWorld'); 
    var matViewUniformLocation  = gl.getUniformLocation(program, 'mView'); 
    var matProjUniformLocation  = gl.getUniformLocation(program, 'mProj');
    
    var viewPosition = [0, -5, 0];
    var matWorld = new Float32Array(16);
    var matView  = new Float32Array(16);
    var matProj  = new Float32Array(16);
    glMatrix.mat4.identity(matWorld);
    glMatrix.mat4.lookAt(matView, viewPosition, [0, 0, 0], [0, 0, 1]);
    glMatrix.mat4.perspective(matProj, glMatrix.glMatrix.toRadian(30), canvas.width / canvas.height, 0.1, 1000);
    
    gl.uniform3fv(viewPositionLocation, new Float32Array(viewPosition));
    gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, matWorld);
    gl.uniformMatrix4fv(matViewUniformLocation,  gl.FALSE, matView);
    gl.uniformMatrix4fv(matProjUniformLocation,  gl.FALSE, matProj);
    
    // Lighting information
    gl.useProgram(program);
    var ambLightIntUniformLocation = gl.getUniformLocation(program, 'ambLightInt'); 
    var sunlightIntUniformLocation = gl.getUniformLocation(program, 'sun.color'); 
    var sunlightDirUniformLocation = gl.getUniformLocation(program, 'sun.direction'); 
    
    gl.uniform3f(ambLightIntUniformLocation,  0.01,  0.01,  0.01);
    gl.uniform3f(sunlightIntUniformLocation,   1.0,   1.0,   1.0);
    gl.uniform3f(sunlightDirUniformLocation,   4.0,  -3.0,   0.0);
    
    // Main render loop for something like a game in JS (just for info)
    /*
    var loop = function () {
      updateWorld();
      renderWorld();
      if (running)
        requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);
    */
    
    // Our main render loop
    
    var identityMatrix = new Float32Array(16);
    var xRotMat        = new Float32Array(16);
    var zRotMat        = new Float32Array(16);
    glMatrix.mat4.identity(identityMatrix);
    var ang = 0;
    function loop(){
      // rotates the earth
      ang = performance.now() / 1000 / 20 * 2 * Math.PI;
      glMatrix.mat4.rotate(zRotMat, identityMatrix, ang,   [0, 0, 1]);
      glMatrix.mat4.rotate(xRotMat, identityMatrix, Math.PI/3*Math.sin(ang/3), [1, 0, 0]);
      glMatrix.mat4.mul(matWorld, xRotMat, zRotMat);
      gl.uniformMatrix4fv(matWorldUniformLocation, gl.FALSE, matWorld)

      // Resize canvas
      var resized = resizeCanvas(gl);
      if (resized) {
        var minFOV = glMatrix.glMatrix.toRadian(30);
        var vertFOV = minFOV;
        if (canvas.height > canvas.width) {
          var distFOV = canvas.width / Math.tan(minFOV);
          vertFOV = Math.atan(canvas.height / distFOV);
        }
        glMatrix.mat4.perspective(matProj, vertFOV, canvas.width / canvas.height, 0.1, 1000);
      }
      gl.uniformMatrix4fv(matProjUniformLocation, gl.FALSE, matProj)

      // Clears the canvas
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      
      gl.depthFunc(gl.LESS);
      gl.drawElements(gl.TRIANGLES, earthIndices.length, gl.UNSIGNED_SHORT, 0);
      
      requestAnimationFrame(loop); // loop is called when a frame is requested
    }
    requestAnimationFrame(loop);
    
  }).catch(function (err) {console.error(err);});
}

function resizeCanvas(gl) {
  var canvas = gl.canvas;
  if (!canvas)
    return false;

  var canvasBox = canvas.getBoundingClientRect();
  var DPR = window.devicePixelRatio || 1;

  var displayWidth  = Math.round(canvasBox.width  * DPR);
  var displayHeight = Math.round(canvasBox.height * DPR);

  if (canvas.width != displayWidth || canvas.height != displayHeight) {
    canvas.width  = displayWidth;
    canvas.height = displayHeight;
    gl.viewport(0, 0, displayWidth, displayHeight);
    return true;
  }
  return false;
}

function loadTextureToCubemap(gl, img){

}

window.onload = main;
</script>
</html>